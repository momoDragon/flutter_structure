// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'get_users_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$GetUsersStateTearOff {
  const _$GetUsersStateTearOff();

  GetUsersInitial initial() {
    return const GetUsersInitial();
  }

  GettingUsers gettingUsers() {
    return const GettingUsers();
  }

  GotUsers gotUsers({required List<User> users}) {
    return GotUsers(
      users: users,
    );
  }

  ErrorGettingUsers errorGettingUsers({required Exception exception}) {
    return ErrorGettingUsers(
      exception: exception,
    );
  }

  ErrorGettingUsersWithResponseBody errorGettingUsersWithResponseBody(
      {required ErrorResponseBody errorResponseBody}) {
    return ErrorGettingUsersWithResponseBody(
      errorResponseBody: errorResponseBody,
    );
  }
}

/// @nodoc
const $GetUsersState = _$GetUsersStateTearOff();

/// @nodoc
mixin _$GetUsersState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() gettingUsers,
    required TResult Function(List<User> users) gotUsers,
    required TResult Function(Exception exception) errorGettingUsers,
    required TResult Function(ErrorResponseBody errorResponseBody)
        errorGettingUsersWithResponseBody,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? gettingUsers,
    TResult Function(List<User> users)? gotUsers,
    TResult Function(Exception exception)? errorGettingUsers,
    TResult Function(ErrorResponseBody errorResponseBody)?
        errorGettingUsersWithResponseBody,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? gettingUsers,
    TResult Function(List<User> users)? gotUsers,
    TResult Function(Exception exception)? errorGettingUsers,
    TResult Function(ErrorResponseBody errorResponseBody)?
        errorGettingUsersWithResponseBody,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetUsersInitial value) initial,
    required TResult Function(GettingUsers value) gettingUsers,
    required TResult Function(GotUsers value) gotUsers,
    required TResult Function(ErrorGettingUsers value) errorGettingUsers,
    required TResult Function(ErrorGettingUsersWithResponseBody value)
        errorGettingUsersWithResponseBody,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(GetUsersInitial value)? initial,
    TResult Function(GettingUsers value)? gettingUsers,
    TResult Function(GotUsers value)? gotUsers,
    TResult Function(ErrorGettingUsers value)? errorGettingUsers,
    TResult Function(ErrorGettingUsersWithResponseBody value)?
        errorGettingUsersWithResponseBody,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetUsersInitial value)? initial,
    TResult Function(GettingUsers value)? gettingUsers,
    TResult Function(GotUsers value)? gotUsers,
    TResult Function(ErrorGettingUsers value)? errorGettingUsers,
    TResult Function(ErrorGettingUsersWithResponseBody value)?
        errorGettingUsersWithResponseBody,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GetUsersStateCopyWith<$Res> {
  factory $GetUsersStateCopyWith(
          GetUsersState value, $Res Function(GetUsersState) then) =
      _$GetUsersStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$GetUsersStateCopyWithImpl<$Res>
    implements $GetUsersStateCopyWith<$Res> {
  _$GetUsersStateCopyWithImpl(this._value, this._then);

  final GetUsersState _value;
  // ignore: unused_field
  final $Res Function(GetUsersState) _then;
}

/// @nodoc
abstract class $GetUsersInitialCopyWith<$Res> {
  factory $GetUsersInitialCopyWith(
          GetUsersInitial value, $Res Function(GetUsersInitial) then) =
      _$GetUsersInitialCopyWithImpl<$Res>;
}

/// @nodoc
class _$GetUsersInitialCopyWithImpl<$Res>
    extends _$GetUsersStateCopyWithImpl<$Res>
    implements $GetUsersInitialCopyWith<$Res> {
  _$GetUsersInitialCopyWithImpl(
      GetUsersInitial _value, $Res Function(GetUsersInitial) _then)
      : super(_value, (v) => _then(v as GetUsersInitial));

  @override
  GetUsersInitial get _value => super._value as GetUsersInitial;
}

/// @nodoc

class _$GetUsersInitial implements GetUsersInitial {
  const _$GetUsersInitial();

  @override
  String toString() {
    return 'GetUsersState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is GetUsersInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() gettingUsers,
    required TResult Function(List<User> users) gotUsers,
    required TResult Function(Exception exception) errorGettingUsers,
    required TResult Function(ErrorResponseBody errorResponseBody)
        errorGettingUsersWithResponseBody,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? gettingUsers,
    TResult Function(List<User> users)? gotUsers,
    TResult Function(Exception exception)? errorGettingUsers,
    TResult Function(ErrorResponseBody errorResponseBody)?
        errorGettingUsersWithResponseBody,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? gettingUsers,
    TResult Function(List<User> users)? gotUsers,
    TResult Function(Exception exception)? errorGettingUsers,
    TResult Function(ErrorResponseBody errorResponseBody)?
        errorGettingUsersWithResponseBody,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetUsersInitial value) initial,
    required TResult Function(GettingUsers value) gettingUsers,
    required TResult Function(GotUsers value) gotUsers,
    required TResult Function(ErrorGettingUsers value) errorGettingUsers,
    required TResult Function(ErrorGettingUsersWithResponseBody value)
        errorGettingUsersWithResponseBody,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(GetUsersInitial value)? initial,
    TResult Function(GettingUsers value)? gettingUsers,
    TResult Function(GotUsers value)? gotUsers,
    TResult Function(ErrorGettingUsers value)? errorGettingUsers,
    TResult Function(ErrorGettingUsersWithResponseBody value)?
        errorGettingUsersWithResponseBody,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetUsersInitial value)? initial,
    TResult Function(GettingUsers value)? gettingUsers,
    TResult Function(GotUsers value)? gotUsers,
    TResult Function(ErrorGettingUsers value)? errorGettingUsers,
    TResult Function(ErrorGettingUsersWithResponseBody value)?
        errorGettingUsersWithResponseBody,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class GetUsersInitial implements GetUsersState {
  const factory GetUsersInitial() = _$GetUsersInitial;
}

/// @nodoc
abstract class $GettingUsersCopyWith<$Res> {
  factory $GettingUsersCopyWith(
          GettingUsers value, $Res Function(GettingUsers) then) =
      _$GettingUsersCopyWithImpl<$Res>;
}

/// @nodoc
class _$GettingUsersCopyWithImpl<$Res> extends _$GetUsersStateCopyWithImpl<$Res>
    implements $GettingUsersCopyWith<$Res> {
  _$GettingUsersCopyWithImpl(
      GettingUsers _value, $Res Function(GettingUsers) _then)
      : super(_value, (v) => _then(v as GettingUsers));

  @override
  GettingUsers get _value => super._value as GettingUsers;
}

/// @nodoc

class _$GettingUsers implements GettingUsers {
  const _$GettingUsers();

  @override
  String toString() {
    return 'GetUsersState.gettingUsers()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is GettingUsers);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() gettingUsers,
    required TResult Function(List<User> users) gotUsers,
    required TResult Function(Exception exception) errorGettingUsers,
    required TResult Function(ErrorResponseBody errorResponseBody)
        errorGettingUsersWithResponseBody,
  }) {
    return gettingUsers();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? gettingUsers,
    TResult Function(List<User> users)? gotUsers,
    TResult Function(Exception exception)? errorGettingUsers,
    TResult Function(ErrorResponseBody errorResponseBody)?
        errorGettingUsersWithResponseBody,
  }) {
    return gettingUsers?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? gettingUsers,
    TResult Function(List<User> users)? gotUsers,
    TResult Function(Exception exception)? errorGettingUsers,
    TResult Function(ErrorResponseBody errorResponseBody)?
        errorGettingUsersWithResponseBody,
    required TResult orElse(),
  }) {
    if (gettingUsers != null) {
      return gettingUsers();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetUsersInitial value) initial,
    required TResult Function(GettingUsers value) gettingUsers,
    required TResult Function(GotUsers value) gotUsers,
    required TResult Function(ErrorGettingUsers value) errorGettingUsers,
    required TResult Function(ErrorGettingUsersWithResponseBody value)
        errorGettingUsersWithResponseBody,
  }) {
    return gettingUsers(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(GetUsersInitial value)? initial,
    TResult Function(GettingUsers value)? gettingUsers,
    TResult Function(GotUsers value)? gotUsers,
    TResult Function(ErrorGettingUsers value)? errorGettingUsers,
    TResult Function(ErrorGettingUsersWithResponseBody value)?
        errorGettingUsersWithResponseBody,
  }) {
    return gettingUsers?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetUsersInitial value)? initial,
    TResult Function(GettingUsers value)? gettingUsers,
    TResult Function(GotUsers value)? gotUsers,
    TResult Function(ErrorGettingUsers value)? errorGettingUsers,
    TResult Function(ErrorGettingUsersWithResponseBody value)?
        errorGettingUsersWithResponseBody,
    required TResult orElse(),
  }) {
    if (gettingUsers != null) {
      return gettingUsers(this);
    }
    return orElse();
  }
}

abstract class GettingUsers implements GetUsersState {
  const factory GettingUsers() = _$GettingUsers;
}

/// @nodoc
abstract class $GotUsersCopyWith<$Res> {
  factory $GotUsersCopyWith(GotUsers value, $Res Function(GotUsers) then) =
      _$GotUsersCopyWithImpl<$Res>;
  $Res call({List<User> users});
}

/// @nodoc
class _$GotUsersCopyWithImpl<$Res> extends _$GetUsersStateCopyWithImpl<$Res>
    implements $GotUsersCopyWith<$Res> {
  _$GotUsersCopyWithImpl(GotUsers _value, $Res Function(GotUsers) _then)
      : super(_value, (v) => _then(v as GotUsers));

  @override
  GotUsers get _value => super._value as GotUsers;

  @override
  $Res call({
    Object? users = freezed,
  }) {
    return _then(GotUsers(
      users: users == freezed
          ? _value.users
          : users // ignore: cast_nullable_to_non_nullable
              as List<User>,
    ));
  }
}

/// @nodoc

class _$GotUsers implements GotUsers {
  const _$GotUsers({required this.users});

  @override
  final List<User> users;

  @override
  String toString() {
    return 'GetUsersState.gotUsers(users: $users)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is GotUsers &&
            const DeepCollectionEquality().equals(other.users, users));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(users));

  @JsonKey(ignore: true)
  @override
  $GotUsersCopyWith<GotUsers> get copyWith =>
      _$GotUsersCopyWithImpl<GotUsers>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() gettingUsers,
    required TResult Function(List<User> users) gotUsers,
    required TResult Function(Exception exception) errorGettingUsers,
    required TResult Function(ErrorResponseBody errorResponseBody)
        errorGettingUsersWithResponseBody,
  }) {
    return gotUsers(users);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? gettingUsers,
    TResult Function(List<User> users)? gotUsers,
    TResult Function(Exception exception)? errorGettingUsers,
    TResult Function(ErrorResponseBody errorResponseBody)?
        errorGettingUsersWithResponseBody,
  }) {
    return gotUsers?.call(users);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? gettingUsers,
    TResult Function(List<User> users)? gotUsers,
    TResult Function(Exception exception)? errorGettingUsers,
    TResult Function(ErrorResponseBody errorResponseBody)?
        errorGettingUsersWithResponseBody,
    required TResult orElse(),
  }) {
    if (gotUsers != null) {
      return gotUsers(users);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetUsersInitial value) initial,
    required TResult Function(GettingUsers value) gettingUsers,
    required TResult Function(GotUsers value) gotUsers,
    required TResult Function(ErrorGettingUsers value) errorGettingUsers,
    required TResult Function(ErrorGettingUsersWithResponseBody value)
        errorGettingUsersWithResponseBody,
  }) {
    return gotUsers(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(GetUsersInitial value)? initial,
    TResult Function(GettingUsers value)? gettingUsers,
    TResult Function(GotUsers value)? gotUsers,
    TResult Function(ErrorGettingUsers value)? errorGettingUsers,
    TResult Function(ErrorGettingUsersWithResponseBody value)?
        errorGettingUsersWithResponseBody,
  }) {
    return gotUsers?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetUsersInitial value)? initial,
    TResult Function(GettingUsers value)? gettingUsers,
    TResult Function(GotUsers value)? gotUsers,
    TResult Function(ErrorGettingUsers value)? errorGettingUsers,
    TResult Function(ErrorGettingUsersWithResponseBody value)?
        errorGettingUsersWithResponseBody,
    required TResult orElse(),
  }) {
    if (gotUsers != null) {
      return gotUsers(this);
    }
    return orElse();
  }
}

abstract class GotUsers implements GetUsersState {
  const factory GotUsers({required List<User> users}) = _$GotUsers;

  List<User> get users;
  @JsonKey(ignore: true)
  $GotUsersCopyWith<GotUsers> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ErrorGettingUsersCopyWith<$Res> {
  factory $ErrorGettingUsersCopyWith(
          ErrorGettingUsers value, $Res Function(ErrorGettingUsers) then) =
      _$ErrorGettingUsersCopyWithImpl<$Res>;
  $Res call({Exception exception});
}

/// @nodoc
class _$ErrorGettingUsersCopyWithImpl<$Res>
    extends _$GetUsersStateCopyWithImpl<$Res>
    implements $ErrorGettingUsersCopyWith<$Res> {
  _$ErrorGettingUsersCopyWithImpl(
      ErrorGettingUsers _value, $Res Function(ErrorGettingUsers) _then)
      : super(_value, (v) => _then(v as ErrorGettingUsers));

  @override
  ErrorGettingUsers get _value => super._value as ErrorGettingUsers;

  @override
  $Res call({
    Object? exception = freezed,
  }) {
    return _then(ErrorGettingUsers(
      exception: exception == freezed
          ? _value.exception
          : exception // ignore: cast_nullable_to_non_nullable
              as Exception,
    ));
  }
}

/// @nodoc

class _$ErrorGettingUsers implements ErrorGettingUsers {
  const _$ErrorGettingUsers({required this.exception});

  @override
  final Exception exception;

  @override
  String toString() {
    return 'GetUsersState.errorGettingUsers(exception: $exception)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ErrorGettingUsers &&
            const DeepCollectionEquality().equals(other.exception, exception));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(exception));

  @JsonKey(ignore: true)
  @override
  $ErrorGettingUsersCopyWith<ErrorGettingUsers> get copyWith =>
      _$ErrorGettingUsersCopyWithImpl<ErrorGettingUsers>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() gettingUsers,
    required TResult Function(List<User> users) gotUsers,
    required TResult Function(Exception exception) errorGettingUsers,
    required TResult Function(ErrorResponseBody errorResponseBody)
        errorGettingUsersWithResponseBody,
  }) {
    return errorGettingUsers(exception);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? gettingUsers,
    TResult Function(List<User> users)? gotUsers,
    TResult Function(Exception exception)? errorGettingUsers,
    TResult Function(ErrorResponseBody errorResponseBody)?
        errorGettingUsersWithResponseBody,
  }) {
    return errorGettingUsers?.call(exception);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? gettingUsers,
    TResult Function(List<User> users)? gotUsers,
    TResult Function(Exception exception)? errorGettingUsers,
    TResult Function(ErrorResponseBody errorResponseBody)?
        errorGettingUsersWithResponseBody,
    required TResult orElse(),
  }) {
    if (errorGettingUsers != null) {
      return errorGettingUsers(exception);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetUsersInitial value) initial,
    required TResult Function(GettingUsers value) gettingUsers,
    required TResult Function(GotUsers value) gotUsers,
    required TResult Function(ErrorGettingUsers value) errorGettingUsers,
    required TResult Function(ErrorGettingUsersWithResponseBody value)
        errorGettingUsersWithResponseBody,
  }) {
    return errorGettingUsers(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(GetUsersInitial value)? initial,
    TResult Function(GettingUsers value)? gettingUsers,
    TResult Function(GotUsers value)? gotUsers,
    TResult Function(ErrorGettingUsers value)? errorGettingUsers,
    TResult Function(ErrorGettingUsersWithResponseBody value)?
        errorGettingUsersWithResponseBody,
  }) {
    return errorGettingUsers?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetUsersInitial value)? initial,
    TResult Function(GettingUsers value)? gettingUsers,
    TResult Function(GotUsers value)? gotUsers,
    TResult Function(ErrorGettingUsers value)? errorGettingUsers,
    TResult Function(ErrorGettingUsersWithResponseBody value)?
        errorGettingUsersWithResponseBody,
    required TResult orElse(),
  }) {
    if (errorGettingUsers != null) {
      return errorGettingUsers(this);
    }
    return orElse();
  }
}

abstract class ErrorGettingUsers implements GetUsersState {
  const factory ErrorGettingUsers({required Exception exception}) =
      _$ErrorGettingUsers;

  Exception get exception;
  @JsonKey(ignore: true)
  $ErrorGettingUsersCopyWith<ErrorGettingUsers> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ErrorGettingUsersWithResponseBodyCopyWith<$Res> {
  factory $ErrorGettingUsersWithResponseBodyCopyWith(
          ErrorGettingUsersWithResponseBody value,
          $Res Function(ErrorGettingUsersWithResponseBody) then) =
      _$ErrorGettingUsersWithResponseBodyCopyWithImpl<$Res>;
  $Res call({ErrorResponseBody errorResponseBody});

  $ErrorResponseBodyCopyWith<$Res> get errorResponseBody;
}

/// @nodoc
class _$ErrorGettingUsersWithResponseBodyCopyWithImpl<$Res>
    extends _$GetUsersStateCopyWithImpl<$Res>
    implements $ErrorGettingUsersWithResponseBodyCopyWith<$Res> {
  _$ErrorGettingUsersWithResponseBodyCopyWithImpl(
      ErrorGettingUsersWithResponseBody _value,
      $Res Function(ErrorGettingUsersWithResponseBody) _then)
      : super(_value, (v) => _then(v as ErrorGettingUsersWithResponseBody));

  @override
  ErrorGettingUsersWithResponseBody get _value =>
      super._value as ErrorGettingUsersWithResponseBody;

  @override
  $Res call({
    Object? errorResponseBody = freezed,
  }) {
    return _then(ErrorGettingUsersWithResponseBody(
      errorResponseBody: errorResponseBody == freezed
          ? _value.errorResponseBody
          : errorResponseBody // ignore: cast_nullable_to_non_nullable
              as ErrorResponseBody,
    ));
  }

  @override
  $ErrorResponseBodyCopyWith<$Res> get errorResponseBody {
    return $ErrorResponseBodyCopyWith<$Res>(_value.errorResponseBody, (value) {
      return _then(_value.copyWith(errorResponseBody: value));
    });
  }
}

/// @nodoc

class _$ErrorGettingUsersWithResponseBody
    implements ErrorGettingUsersWithResponseBody {
  const _$ErrorGettingUsersWithResponseBody({required this.errorResponseBody});

  @override
  final ErrorResponseBody errorResponseBody;

  @override
  String toString() {
    return 'GetUsersState.errorGettingUsersWithResponseBody(errorResponseBody: $errorResponseBody)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ErrorGettingUsersWithResponseBody &&
            const DeepCollectionEquality()
                .equals(other.errorResponseBody, errorResponseBody));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(errorResponseBody));

  @JsonKey(ignore: true)
  @override
  $ErrorGettingUsersWithResponseBodyCopyWith<ErrorGettingUsersWithResponseBody>
      get copyWith => _$ErrorGettingUsersWithResponseBodyCopyWithImpl<
          ErrorGettingUsersWithResponseBody>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() gettingUsers,
    required TResult Function(List<User> users) gotUsers,
    required TResult Function(Exception exception) errorGettingUsers,
    required TResult Function(ErrorResponseBody errorResponseBody)
        errorGettingUsersWithResponseBody,
  }) {
    return errorGettingUsersWithResponseBody(errorResponseBody);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? gettingUsers,
    TResult Function(List<User> users)? gotUsers,
    TResult Function(Exception exception)? errorGettingUsers,
    TResult Function(ErrorResponseBody errorResponseBody)?
        errorGettingUsersWithResponseBody,
  }) {
    return errorGettingUsersWithResponseBody?.call(errorResponseBody);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? gettingUsers,
    TResult Function(List<User> users)? gotUsers,
    TResult Function(Exception exception)? errorGettingUsers,
    TResult Function(ErrorResponseBody errorResponseBody)?
        errorGettingUsersWithResponseBody,
    required TResult orElse(),
  }) {
    if (errorGettingUsersWithResponseBody != null) {
      return errorGettingUsersWithResponseBody(errorResponseBody);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(GetUsersInitial value) initial,
    required TResult Function(GettingUsers value) gettingUsers,
    required TResult Function(GotUsers value) gotUsers,
    required TResult Function(ErrorGettingUsers value) errorGettingUsers,
    required TResult Function(ErrorGettingUsersWithResponseBody value)
        errorGettingUsersWithResponseBody,
  }) {
    return errorGettingUsersWithResponseBody(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(GetUsersInitial value)? initial,
    TResult Function(GettingUsers value)? gettingUsers,
    TResult Function(GotUsers value)? gotUsers,
    TResult Function(ErrorGettingUsers value)? errorGettingUsers,
    TResult Function(ErrorGettingUsersWithResponseBody value)?
        errorGettingUsersWithResponseBody,
  }) {
    return errorGettingUsersWithResponseBody?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(GetUsersInitial value)? initial,
    TResult Function(GettingUsers value)? gettingUsers,
    TResult Function(GotUsers value)? gotUsers,
    TResult Function(ErrorGettingUsers value)? errorGettingUsers,
    TResult Function(ErrorGettingUsersWithResponseBody value)?
        errorGettingUsersWithResponseBody,
    required TResult orElse(),
  }) {
    if (errorGettingUsersWithResponseBody != null) {
      return errorGettingUsersWithResponseBody(this);
    }
    return orElse();
  }
}

abstract class ErrorGettingUsersWithResponseBody implements GetUsersState {
  const factory ErrorGettingUsersWithResponseBody(
          {required ErrorResponseBody errorResponseBody}) =
      _$ErrorGettingUsersWithResponseBody;

  ErrorResponseBody get errorResponseBody;
  @JsonKey(ignore: true)
  $ErrorGettingUsersWithResponseBodyCopyWith<ErrorGettingUsersWithResponseBody>
      get copyWith => throw _privateConstructorUsedError;
}
